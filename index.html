<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>CsvHelper</title>
    <meta name="description" content="A .NET library for reading and writing CSV files. Extremely fast, flexible, and easy to use. Supports reading and writing of custom class objects.">

    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="bootstrap/css/bootstrap-responsive.min.css"/>
	<link rel="stylesheet" href="codemirror/codemirror.css"/>
	<link rel="stylesheet" href="css/main.css"/>
</head>
<body data-spy="scroll" data-target="">
<!--[if lt IE 7]><p class=chromeframe>Your browser is <em>ancient!</em> <a href="http://browsehappy.com/">Upgrade to a different browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to experience this site.</p><![endif]-->

<header>
	<div class="navbar navbar-fixed-top">
		<div class=navbar-inner>
			<div class="container">
				<a href="#" class="home-link pull-left"><img src="images/logo-small.png" width="30" height="30" /></a>
				<ul class="nav">
					<li><a href="#getting-started">Getting Started</a></li>
					<li><a href="#reading">Reading</a></li>
					<li><a href="#writing">Writing</a></li>
					<li><a href="#mapping">Mapping</a></li>
					<li><a href="#configuration">Configuration</a></li>
					<li><a href="#type-conversion">Type Conversion</a></li>
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Misc<b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#change-log">Change Log</a></li>
						</ul>
					</li>
				</ul>
			</div>

			<a href="https://github.com/joshclose/csvhelper" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
		</div>
	</div>
</header>

<div class="container">
	<h1>CsvHelper</h1>
	<p>A .NET library for reading and writing CSV files. Extremely fast, flexible and easy to use. Supports reading and writing of custom class objects.</p>

	<h2 id="getting-started">Getting Started</h2>

	<p>
		To install CsvHelper, run the following from the <a href="http://docs.nuget.org/docs/start-here/using-the-package-manager-console" target="_blank">Package Manager Console.</a>
	</p>

	<p><textarea data-code="">Install-Package CsvHelper</textarea></p>

	<!-- Reading -->
	<section>
	<h2 id="reading">Reading</h2>

	<h3>Reading all records</h3>

	<p>Reading is setup to be as simple as possible. If you have a class structure setup that mirrors the CSV file,
	you can read the whole file into an enumerable.</p>

	<p><textarea>
var csv = new CsvReader( textReader );
var records = csv.GetRecords&lt;MyClass&gt;();</textarea></p>

	<p>If you want to customize how the CSV file maps to your custom class objects, you can use <a href="#mapping">mapping</a>.</p>

	<p>The IEnumerable&lt;T&gt; that is returned will yield results. This means that a result isn't returned until you
	actually access it. This is handy because the whole file won't be loaded into memory, and the file will be read as
	you access each row. If you do something like Count() on the IEnumerable&lt;T&gt;, the whole file needs to be read
	and you won't be able to iterate over it again without starting over. If you need to iterate the records more than
	once (like using Count), you can load everything into a list and the work on the data.</p>

	<p><textarea>
var csv = new CsvReader( textReader );
var records = csv.GetRecords&lt;MyClass&gt;().ToList();</textarea></p>

	<h3>Reading records manually</h3>

	<p>You can loop the rows and read them manually.</p>

	<p><textarea>
var csv = new CsvReader( textReader );
while( csv.Read() )
{
	var record = csv.GetRecord&lt;MyClass&gt;();
}</textarea></p>

	<h3>Reading individual fields</h3>

	<p>You can also read each field manually if you like.</p>

	<p><textarea>
var csv = new CsvReader( textReader );
while( csv.Read() )
{
	var intField = csv.GetField&lt;int&gt;( 0 );
	var stringField = csv.GetField&lt;string&gt;( 1 );
	var boolField = csv.GetField&lt;bool&gt;( "HeaderName" );
}</textarea></p>

	<h3>TryGetField</h3>

	<p>If you might have inconsistencies with getting fields, you can use TryGetField.</p>

	<p><textarea>
var csv = new CsvReader( textReader );
while( csv.Read() )
{
	int intField;
	if( !csv.TryGetField( 0, out intField ) )
	{
		// Do something when it can't convert.
	}
}</textarea></p>
	</section>

	<!-- Writing -->
	<section>
	<h2 id="writing">Writing</h2>
	</section>

	<!-- Mapping -->
	<section>
	<h2 id="mapping">Mapping</h2>

	<h3 id="auto-mapping">Auto Mapping</h3>

	<p>If you don't supply a mapping file, auto mapping will be used. Auto mapping will map the properties in your class
	in the order they appear in. If the property is a custom class, it recursively maps the properties from that class
	in the order they appear in. If the auto mapper hits a circular reference, it will stop going down that reference
	branch.</p>

	<h3 id="fluent-class-mapping">Fluent Class Mapping</h3>

	<p>If your CSV file doesn't match up exactly with your custom class, you can use a fluent class map to set options
	for how the class maps to the file. You need to <a href="#register-class-map">register your class map</a> in
	configuration.</p>

	<p><textarea>
public class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public override void CreateMap()
	{
		Map( m => m.Id );
		Map( m = > m.Name );
	}
}</textarea></p>

	<h4>Reference Map</h4>

	<p>Reference maps are used to map a property that is a custom class to it's own mapping that maps those properties
	to several CSV columns. You can nest reference maps as many layers deep as you like.</p>

	<p><textarea>
public class PersonMap : CsvClassMap&lt;Person&gt;
{
	public override void CreateMap()
	{
		Map( m => m.Id );
		Map( m = > m.Name );
		References&lt;AddressMap&gt;( m => m.Address );
	}
}

public class AddressMap : CsvClassMap&lt;Address&gt;
{
	public override void CreateMap()
	{
		Map( m => m.Street );
		Map( m => m.City );
		Map( m => m.State );
		Map( m => m.Zip );
	}
}</textarea></p>

	<h4>Index</h4>

	<p>When mapping by index you specify the index of the CSV column that that you want to use for that property.</p>

	<p><textarea>
public class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public override void CreateMap()
	{
		Map( m => m.Id ).Index( 0 );
		Map( m => m.Name ).Index( 1 );
	}
}</textarea></p>

	<h4>Name</h4>

	<p>When mapping by name you specify the name of the CSV column that you want to use for that property. For this to
	work, the CSV file must have a header record. The name you specify must match with the name of the header record.</p>

	<p><textarea>
public class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public override void CreateMap()
	{
		Map( m => m.Id ).Name( "The Id Column" );
		Map( m => m.Name ).Name( "The Name Column" );
	}
}</textarea></p>

	<h4>Name Index</h4>

	<p>Sometimes CSV files have multiple columns with the same name. When this happens, you can use NameIndex to
	specify which column name you are referring to. The NameIndex is NOT the column in the CSV file.</p>

	<p><textarea>
public class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public override void CreateMap()
	{
		Map( m => m.FirstName ).Name( "Name" ).NameIndex( 0 );
		Map( m => m.LastName ).Name( "Name" ).NameIndex( 1 );
	}
}</textarea></p>

	<h4>Ignore</h4>

	<p>Currently this is not used. Mapping will only map properties that you specify. In the future there will be an
	option to auto map within a class map, and any mappings explicitly stated will override the auto mapped ones. When
	this happens, ignore will be used to ignore a property that was auto mapped.</p>

	<h4>Default</h4>

	<p>Default is used to set a default value you want to use if the field is empty.</p>

	<p><textarea>
public class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public override void CreateMap()
	{
		Map( m => m.Id ).Index( 0 ).Default( -1 );
		Map( m => m.Name ).Index( 1 ).Default( "Unknown" );
	}
}</textarea></p>

	<h4>Type Converter</h4>

	<p>If the value of the CSV field can't automatically be converted into the type of the property, you can specify
	a custom CsvHelper.TypeConversion.ITypeConverter to be used to convert the value. See
	<a href="#type-conversion">Type Conversion</a> for documentation on how to create a custom type converter.</p>

	<p><textarea>
public class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public override void CreateMap()
	{
		Map( m => m.Id ).Index( 0 ).TypeConverter&lt;MyIdConverter&gt;();
	}
}</textarea></p>

	<h4>Type Converter Options</h4>

	<p>The default built in converters will handle most cases of type conversion, but sometimes there are some small
	changes that you'd like to make, but don't want to create a whole new type converter that just parses an int
	(for example) differently. You can specify some type converter options to handle these cases.</p>

	<p><textarea>
public class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public override void CreateMap()
	{
		Map( m => m.Description ).Index( 0 ).TypeConverterOption( CultureInfo.InvariantCulture );
		Map( m => m.TimeStamp ).Index( 1 ).TypeConverterOption( DateTimeStyles.AdjustToUniversal );
		Map( m => m.Cost ).Index( 2 ).TypeConverterOption( NumberStyles.Currency );
		Map( m => m.CurrencyFormat ).Index( 3 ).TypeConverterOption( "C" );
		Map( m => m.BooleanValue ).Index( 4 ).TypeConverterOption( true, "sure" ).TypeConverterOption( false, "nope" );
	}
}</textarea>

	<h4>Convert Using</h4>

	<p>When all else fails, you can use ConvertUsing. ConvertUsing allows you to write custom code inline to
	convert the row into a single property value.</p>

	<p><textarea>
public class MyClassMap : CsvClassMap&lt;MyClass&gt;
{
	public override void CreateMap()
	{
		// Constant value.
		Map( m => m.Constant ).ConvertUsing( row => 3 );
		// Aggregate of two rows.
		Map( m => m.Aggregate ).ConvertUsing( row => row.Get&lt;int&gt;( 0 ) + row.Get&lt;int&gt;( 1 ) );
		// Collection with a single value.
		Map( m => m.Names ).ConvertUsing( row => new List&lt;string&gt;{ row.Get&lt;string&gt;( "Name" ) } );
		// Just about anything.
		Map( m => m.Anything ).ConvertUsing( row =>
		{
			// You can do anything you want in a block.
			// Just make sure to return the same type as the property.
		} );
	}
}</textarea>
	</section>

	<!-- Configuration -->
	<section>
	<h2 id="configuration">Configuration</h2>

	<h3 id="register-class-map">Register Class Map</h3>

	<p>When using fluent class mapping, you need to register class maps for them to be used. You can register multiple
	class maps to be used.</p>

	<p><textarea>
csv.Configuration.RegisterClassMap&lt;MyClassMap&gt;();
csv.Configuration.RegisterClassMap&lt;AnotherClassMap&gt;();</textarea></p>

	<h3>Unregister Class Map</h3>

	<p>You can unregister a class map if needed.</p>

	<p><textarea>
// Unregister single map.
csv.Configuration.UnregisterClassMap&lt;MyClassMap&gt;();
// Unregister all class maps.
csv.Configuration.UnregisterClassMap();</textarea></p>

	<h3>Maps</h3>

	<p>You are able to access the registered class maps.</p>

	<p><textarea>
var myMap = csv.Configuration.Maps[typeof( MyClass )];</textarea></p>

	<h3>Property Binding Flags</h3>

	<p>PropertyBindingFlags are the flags used to find the properties on the custom class.</p>

	<p><textarea>
// Default value
csv.Configuration.PropertyBindingFlags = BindingFlags.Public | BindingFlags.Instance;</textarea></p>

	<h3>Has Header Record</h3>

	<p>This flag tells the reader/writer if there is a header row in the CSV file. The must be true
	for mapping properties by name to work (and there must be a header row).</p>

	<p><textarea>
// Default value
csv.Configuration.HasHeaderRecord = true;</textarea></p>

	<h3>Will Throw On Missing Field</h3>

	<p>This flag indicates if an exception should be thrown if reading and an expected field is missing. This is useful
	if you want to know if there is an issue with the CSV file.</p>

	<p><textarea>
// Default value
csv.Configuration.WillThrowOnMissingField = true;</textarea></p>

	<h3>Detect Column Count Changes</h3>

	<p>This flag will check for changes in the number of column from row to row. If true and a change is detected, a
	CsvBadDataException will be thrown.</p>

	<p><textarea>
// Default value
csv.Configuration.DetectColumnCountChanges = false;</textarea></p>

	<h3>Is Header Case Sensitive</h3>

	<p>This flag sets whether matching CSV header names will be case sensitive.</p>

	<p><textarea>
// Default value
csv.Configuration.IsHeaderCaseSensitive = true;</textarea></p>

	<h3>Ignore Header White Space</h3>

	<p>This flag tells the reader to ignore white space in the headers when matching the columns to the properties by
	name.</p>

	<p><textarea>
// Default value
csv.Configuration.IgnoreHeaderWhiteSpace = false;</textarea></p>

	<h3>Trim Headers</h3>

	<p>This flag tells the reader to ignore white space from the beginning and ending of the headers when matching the
	columns to the properties by name.</p>

	<p><textarea>
// Default value
csv.Configuration.TrimHeaders = false;</textarea></p>

	<h3>Trim Fields</h3>

	<p>This flag tells the reader to trim whitespace from the beginning and ending of the field value when reading.</p>

	<p><textarea>
// Default value
csv.Configuration.TrimFields = false;</textarea></p>

	<h3>Delimiter</h3>

	<p>The value used to separate the fields in a CSV row.</p>

	<p><textarea>
// Default value
csv.Configuration.Delimiter = ",";</textarea></p>

	<h3>Quote</h3>

	<p>The value used to escape fields that contain a delimiter, quote, or line ending.</p>

	<p><textarea>
// Default value
csv.Configuration.Quote = '"';</textarea></p>

	<h3>Comment</h3>

	<p>The value used to denote a line that is commented out.</p>

	<p><textarea>
// Default value
csv.Configuration.Comment = '#';</textarea></p>

	<h3>Allow Comments</h3>

	<p>This flag tells the parser whether comments are enabled.</p>

	<p><textarea>
// Default value
csv.Configuration.AllowComments = false;</textarea></p>

	<h3>Buffer Size</h3>

	<p>The size of the internal buffer that is used when reader or writing data to and from the TextReader and
	TextWriter. Depending on where your TextReader or TextWriter came from, you may want to make this value larger or
	smaller.</p>

	<p><textarea>
// Default value
csv.Configuration.BufferSize = 2048;</textarea></p>

	<h3>Quote All Fields</h3>

	<p>A flag that tells the writer whether all fields written should have quotes around them; regardless if the field
	contains anything that should be escaped. Both QuoteAllFields and QuoteNotFields cannot be true at the same time.
	Setting one to true will set the other to false.</p>

	<p><textarea>
// Default value
csv.Configuration.QuoteAllFields = false;</textarea></p>

	<h3>Quote No Fields</h3>

	<p>A flag that tell the writer whether all fields written should not have quotes around them; regardless if the
	field contains anything that should be escaped. Both QuoteAllFields and QuoteNotFields cannot be true at the same
	time. Setting one to true will set the other to false.</p>

	<p><textarea>
// Default value
csv.Configuration.QuoteAllFields = false;</textarea></p>

	<h3>Count Bytes</h3>

	<p>A flag that will tell the parser to keep a count of all the bytes that have been read. You need to set
	Configuration.Encoding to the same encoding of the CSV file for this to work properly. This will also slow down
	parsing of the file.</p>

	<p><textarea>
// Default value
csv.Configuration.CountBytes = false;</textarea></p>

	<h3>Encoding</h3>

	<p>The encoding of the CSV file. This is only used when counting bytes. The underlying TextReader and TextWriter
	will have it's own encoding that is used.</p>

	<p><textarea>
// Default value
csv.Configuration.Encoding = Encoding.UTF8;</textarea></p>

	<h3>Culture Info</h3>

	<p>The culture info used to read and write. This can be overridden per property in the mapping configuration.</p>

	<p><textarea>
// Default value
csv.Configuration.CultureInfo = CultureInfo.CurrentCulture;</textarea></p>

	<h3>Skip Empty Records</h3>

	<p>A flag to let the reader know if a record should be skipped when reading if it's empty. A record is considered
	empty if all fields are empty.</p>

	<p><textarea>
// Default value
csv.Configuration.SkipEmptyRecords = false;</textarea></p>

	<h3>Ignore Quotes</h3>

	<p>A flag that tells the parser to ignore quotes as an escape character and treat it like any other character.</p>

	<p><textarea>
// Default value
csv.Configuration.IgnoreQuotes = false;</textarea></p>

	<h3>Ignore Private Accessor</h3>

	<p>A flag that tells the reader and writer to ignore private accessors when reading and writing. By default you
	can't read from a private getter or write to a private setter. Turn this on will allow that. Properties that can't
	be read from or written to are silently ignored.</p>

	<p><textarea>
// Default value
csv.Configuration.IgnorePrivateAccessor = false;</textarea></p>

	<h3>Ignore Reading Exceptions</h3>

	<p>A flag that tells the reader to swallow any exceptions that occur while reading and to continue on. Exceptions
	that occur in the parser will not be ignored. Parser exceptions mean the file is bad in some way, and the parser
	isn't able to recover.</p>

	<p><textarea>
// Default value
csv.Configuration.IgnoreReadingExceptions = false;</textarea></p>

	<h3>Reading Exception Callback</h3>

	<p>If you have Configuration.IgnoreReaderExceptions on and you want to know that the exceptions have occurred and
	possibly do something with them, you can use this.</p>

	<p><textarea>
csv.Configuration.ReadingExceptionCallback = ( ex, row ) =>
{
	// Log the exception and current row information.
};</textarea></p>

	<h3>Auto Map</h3>

	<p>This is used to generate a CsvClassMap from a type automatically without a fluent class mapping. This will try
	to map all properties including creating reference maps for properties that aren't native types. If the auto mapper
	detects a circular reference, it will not continue down that path.</p>

	<p><textarea>
var generatedMap = csv.Configuration.AutoMap&lt;MyClass&gt;();</textarea></p>
	</section>

	<!-- Type Conversion -->
	<section>
	<h2 id="type-conversion">Type Conversion</h2>
	</section>

	<!-- Miscellaneous -->
	<section>
	<h2>Miscellaneous</h2>

	<h3 id="change-log">Change Log</h3>

	<h4>2.1.1</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed issue when WillThrowOnMissingField is off and exception was still being thrown.</li>
	</ul>

	<h4>2.1.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Made RegisterClassMap overload with CsvClassMap instance public.</li>
	</ul>

	<h4>2.0.1</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Made a WinRT Any CPU build and removed the arch specific WinRT builds.</li>
	</ul>

	<h4>2.0.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Added parser configuration to ignoring quotes and treating them like any other character.</li>
		<li>Added CsvFactory to create ICsvParser, ICsvReader, and ICsvWriter classes. This is useful
		when you need to unit test code that uses CsvHelper since these 3 classes require a TextReader
		or TextWriter to work.</li>
		<li>All assembly versions are strong named but will use a single version of 2.0.0.0. The file
		version and NuGet versions will change with every release.</li>
		<li>Removed class type constraint from reading and writing.</li>
		<li>Added non-generic class mapping overload.</li>
		<li>WriteRecords param changed from IEnumerable&ltobject&gt to non-generic IEnumerable.</li>
		<li>Value types can be read and written instead of just custom classes.</li>
		<li>Indexes are automatically set and incremented when mapping in order of the Map and Reference calls.</li>
		<li>Auto mapping with circular reference detection.</li>
		<li>Config option to ignore spaces in header names.</li>
		<li>Fixed exception handling. Exception are no longer wrapped. Exception.Data["CsvHelper"] contains
		CsvHelper specific exception info.</li>
		<li>Row exception can be skipped during GetRecords.</li>
		<li>Renamed IsStrictMode to WillThrowOnMissingField.</li>
		<li>Window Phone 7 & 8 builds.</li>
		<li>Auto mapping will use defined maps if available.</li>
		<li>Type converter options.</li>
		<li>Added IEnumerable converter that throws an exception so people will know that converting to/from
		and enumerable is not supported instead of getting a cryptic error message.</li>
		<li>Dynamic support for reading and writing.</li>
		<li>Multiple maps can be supplied.</li>
		<li>Renamed InvalidateRecordCache to ClearRecordCache.</li>
		<li>Recursive reference mapping down the whole mapping tree.</li>
		<li>Configuration.CultureInfo was added in place of Configuration.UseInvariantCulture.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Getting the exception helper message failed when writing because no parser is available.</li>
		<li>WriteRecords Dynamic invoke had wrong parameter count.</li>
		<li>GetField( string ) was not returning null if the header is not found.</li>
		<li>CsvBadDataException when there were extra columns in the row.</li>
		<li>Raw record corruption.</li>
	</ul>

	<h4>1.17.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Ignore properties that can't be set in attribute mapping.</li>
		<li>Made TypeConverterFactory thread safe.</li>
		<li>Added remove converter method.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue with writer exception in WinRT.</li>
	</ul>

	<h4>1.16.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Change TypeConverterFactory to use a set of cache type converters so global type converters can be used.</li>
		<li>Added GetField&lt;T, TConverter&gt; overloads.</li>
		<li>Changed all Activator.CreateInstance calls to use compiled expression trees to create them instead.</li>
		<li>Changed mapping for ConvertUsing to accept a Func so a block expression can be used.</li>
	</ul>

	<h4>1.15.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Support for Silverlight 4 & 5.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue where writing with Configuration.QuoteAllFields enabled will not quote the quotes inside the field.</li>
		<li>Issue with WinRT not building after pull request merge.</li>
	</ul>

	<h4>1.14.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Parse full line on read. This allows for the parser to retain the whole unchanged raw CSV lin on a read.</li>
		<li>Changed delimiter config from a char to a string.</li>
		<li>Iterating records multiple times will throw a CsvReaderException. This is to help stop confusion when 0 results
		are returned the second iteration.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue where EnumConverter isn't created correctly from the TypeConverterFactory.</li>
		<li>Issue with updating count for all closing quotes.</li>
	</ul>

	<h4>1.13.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Configuration to always not quote all fields.</li>
		<li>WriteHeader method is public.</li>
		<li>Added enum converter.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue with boolean converter returning true for "no" value.</li>
		<li>Issue with GetMethod in WinRT.</li>
	</ul>

	<h4>1.12.1</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Isse where an exception was being thrown when reading all records multiple times.</li>
	</ul>

	<h4>1.12.0</h4>

	<h5>Features</h5>

	<ul>
		<li>WinRT support.</li>
	</ul>

	<h4>1.11.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Better exception information added to CsvBadDataException.</li>
	</ul>

	<h4>1.10.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Mapping property for CreateUsing which allows user to specify how the property gets created.</li>
	</ul>

	<h4>1.9.2</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue with skipping empty records.</li>
	</ul>

	<h4>1.9.1</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue with detecting column count changes.</li>
	</ul>

	<h4>1.9.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Added properties to CsvReaderException to give more information about the error.</li>
		<li>Ability to skip empty records based on config settings.</li>
		<li>Getting by index that doesn't exist will give a default or CsvMissingFieldException.</li>
		<li>Made column count detection a config setting.</li>
		<li>Map option for constructing the row object.</li>
		<li>Throw exception when inconsistent column lengths are detected.</li>
		<li>String.Format support in CsvWriter.</li>
		<li>Excel compatible parsing.</li>
		<li>Parser can keep track of the byte position using an encoding so a user cna seek to a stream and start
		reading from there.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed bug with column count detection.</li>
		<li>Issue with double counting the closing quote.</li>
		<li>Issue where parsing was incorrect when the last row didn't have a CRLF at the end.</li>
		<li>Issue with error messages.</li>
	</ul>

	<h4>1.8.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Writer overload for shouldQuote when writing a field.</li>
		<li>Ability for using alternative names for headers in the configuration.</li>
		<li>Better error messages.</li>
	</ul>

	<h4>1.7.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Configuration to quote all fields when writing.</li>
		<li>Parser keeps a char count of where it's at.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed subclass issue by having the reader and writer use interfaces instead of concrete classes.</li>
	</ul>

	<h4>1.6.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Custom boolean type converter that can convert from 1 and 0 besides the normal conversion.</li>
		<li>Property map configuration to set a default value.</li>
		<li>CsvWriter no longer flushes to the output stream after every record.</li>
		<li>Non-generic overloads for reading, writing, and attribute mapping.</li>
		<li>Invalidate record cache will clear the properties list.</li>
	</ul>

	<h4>1.5.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Support .NET 2.0 and 3.5 builds.</li>
	</ul>

	<h4>1.4.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Case insensitive header matching.</li>
	</ul>

	<h4>1.3.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Removed CsvHelper class.</li>
		<li>Property reference mapping. One level deep.</li>
	</ul>

	<h4>1.2.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Support for multiple duplicate header names.</li>
	</ul>

	<h4>1.1.2</h4>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Issue when using a readonly or writeonly stream and disposing causes an exception.</li>
	</ul>

	<h4>1.1.1</h4>

	<h5>Features</h5>

	<ul>
		<li>Updated CsvHelper.cs to allow for readonly and writeonly stream.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed DateTimeConverter issue where a white space string would return a DateTime.MinValue instead of null.</li>
	</ul>

	<h4>1.1.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Changed .NET 3.5 project to client profile.</li>
		<li>Added getter for the current record in the header.</li>
	</ul>

	<h4>1.0.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Changed strict mode to default to true.</li>
		<li>Renamed strict mode configuration property.</li>
		<li>Changed reader to not throw an exception when there are duplicate header records unless in strict mode.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed bug where if there is no line ending at the end of the file, the last field would be null instead of
			an empty string.</li>
		<li>Fixed configuration references and constructor signatures.</li>
	</ul>

	<h4>0.16.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Added configuration option for using CultureInvariant to read/write.</li>
		<li>Updated the reader/writer to use the config option.</li>
		<li>Both CsvReader and CsvWriter are using Local culture when converting from/to strings.</li>
		<li>CsvClassMap without generic argument.</li>
	</ul>

	<h4>0.15.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Changed TryGetField&lt;T&gt; to do a low level check instead of jsut wrapping in try/catch blocks.</li>
		<li>Removed non generic TryGetField methods.</li>
		<li>Formatting changes.</li>
		<li>Changed CsvParser to use the Configuration.Comment char instead of #.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed indentation error caused by new constructor in CsvPropertyMap.</li>
	</ul>

	<h4>0.14.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Changed GetRecords&lt;T&gt; to return IEnumerable&lt;T&gt;.</li>
		<li>Added convenience constructor to CsvPropertyMap.</li>
		<li>Major configuration overhaul.</li>
		<li>Changed end of file check to be more low level.</li>
		<li>Final record is returned if there is a trailing delimiter.</li>
		<li>Added an exception re-throw to parsing that tells the line and character number.</li>
		<li>Added ability to change what the quote char is.</li>
		<li>Added CSV specific exceptions.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fix for issue when CsvHelper uses CurrentCulture instead of InvariantCulture.</li>
	</ul>

	<h4>0.13.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Changed StreamReader to TextReader to be more generic.</li>
	</ul>

	<h4>0.12.0</h4>

	<h5>Features</h5>

	<ul>
		<li>Added option to have a commented out line using '#' as the first character of the line.</li>
	</ul>

	<h5>Bug Fixes</h5>

	<ul>
		<li>Fixed issue with spaces in non-quoted field.</li>
	</ul>

	</section>
</div>

<script src="js/jquery-1.10.1.min.js"></script>
<script src="bootstrap/js/bootstrap.min.js"></script>
<script src="codemirror/codemirror.js"></script>
<script src="codemirror/mode/clike/clike.js"></script>
<script src="js/main.js"></script>

<!--
<script>
    var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
        g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
        s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
-->
</body>
</html>